# 排序

> 选泡插
> 快归堆希统计基

## 选择排序

* 步骤
  * 每次寻找最大位置，和未排序数组最后一个元素交换
  * 重复 n 次
* 应用
  * 选择：基本不用，不稳定


## 冒泡排序

* 步骤：
  * 一趟冒泡，将最值 ‘浮动’ 到未排序数组顶端
  * 重复 n 次
* 优化：
  * 外层循环记录是否交换，若未交换，则已有序，直接结束
  * 内层循环记录最后一次交换位置，该位置后均为有序，下一轮无需比较
* 应用
  * 选择：基本不用，太慢

## 插入排序

* 步骤：
  * 将待排数组看作两部分：已排序和未排序。将待排序元素从后向前插入已有序的数组（从后向前移动数组，数组常用 trick）
* 优化：
  * 折半查找
* 应用：
  * **样本小** 且 **基本有序** 的时候效率高


## 快速排序

* 步骤
  * 确定 pivot 的位置，并二分，需要注意的细节
    * 因为是确定 pivot 左右两侧的元素，无需 <= , left < right
    * 先从右面寻找，替换而不是交换
    * 等于 pivot 的元素不重要
    * 注意判断 start < end
    * nums[start] = nums[pivot](考虑无需交换的情况，nums[start] = nums[start])
  * 递归执行

* 优化
  * 三数取中法
  * 双轴快排

* 缺点
  * 排序有序时，转换为冒泡排序

* 应用
  * 较大规模**基本数据类型**常用排序算法


## 归并排序

该算法采用分治（divide and conquer）策略（分——分为小问题，递归求解，治——将分中的小问题合在一起）

![](../pic/1024555-20161218163120151-452283750.png)

* 步骤
  * 分/治

* 应用
  * java对象排序：对象排序一般要求稳定(LegacyMergeSort、TimSort)

* 改进
  * TimSort
    * 二分插入


## 堆排序

堆：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。

* 步骤
  * 构建初始堆：将待排序序列构造成一个大顶堆(从最后一个父节点向前进行堆调整)，O(n)
  * 将堆顶与末尾元素交换，并重新调整结构，使其满足堆定义(O(logn))
  * 执行 n 次


## 希尔排序

希尔排序是第一批冲破 O(n^2) 的算法之一。

* 步骤
  * 每个一定的 gap 进行插入排序
  * 缩小 gap 进行插入排序

* Knuth 序列
  * h = 1
  * h = 3*h + 1
  * h > arr.length / 3  结束

## 桶排序

* 步骤
  * 确定数据范围，确定桶范围
  * 遍历原始数组，将每个对象放入对应的桶中
  * 对每个非空桶进行排序
  * 按顺序访问桶，并将所有元素放回原始数组中


## 计数排序

非比较排序，桶思想的一种

* 适用情况
  * 适用特定情况：量大但范围小（某大型企业数万名员工年龄排序、快速得知高考名次（腾讯面试））

* 步骤
  * 声明和待排序等长的数组，以及和数据范围等长的数组 count
  * 遍历待排序数组，count[num] ++
  * 从小到大遍历count, count[i] 多大，输出多少个 i

* 改进
  * 不稳定->稳定
  * count[i] = count[i] + count[i-1]
  * 从后向前放置原数组

## 基数排序

非比较排序，桶思想的一种, 多关键字排序

* 步骤
  * 对每一个数位进行计数排序
  * 对所有数位计数排序后完成基数排序

* 应用：
  * 字符串排序



## 时间、空间复杂度及稳定性总结

| 排序方法      |     时间复杂度(好/平均/差) |   空间复杂度   | 稳定性 |
| :---------:   | :--------:    | :------:      | :-----:|
| 简单选择排序   |   O(N^2)/O(N^2)/O(N^2)   |  O(1)       | 不稳定   |
| 冒泡排序       |  O(N)/O(N^2)/O(N^2)      |      O(1)   | 稳定     |
| 直接插入排序   |   O(N)/O(N^2)/O(N^2)     |        O(1) |    稳定  |  
| 折半插入排序   |   O(NlogN)/O(N^2)/O(N^2) |     O(1)    |  稳定    |
| 快速排序       | O(NlongN)/O(NlogN)/O(N^2)   |  **O(logN)** | 不稳定  |
| 归并排序       |  O(NlogN)/O(NlogN)/O(NlogN  |   **O(N)** |  **稳定** |
| 堆排序         |  O(NlogN)/O(NlogN)/O(NlogN)   |  O(1)| **不稳定**    |
| 希尔排序       |             |          O(1) | 不稳定 |
| 桶排序       |       O(N+C)      |        O(N+M) | 取决于桶内排序算法 |
| 计数排序      |    O(N+m)(m为数据范围)    | O(N+m)|      稳定          |
| 基数排序      |           O(d(n+k))    |    O(N+k) |          稳定  |


## 快速排序高效的原因

快速排序相对于其他排序算法的优势在于在相同 数据量的情况下，它的运算效率最高，并且它额外所需空间最小。

从时间复杂度的角度来看，归并排序、堆排序和快速排序的时间复杂度最小。

从空间复杂度的角度来看，在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，归并排序首先就被排除掉了。

堆排序与快速排序相比，主要是从缓存的局部性原理考虑的。堆排序来说，它最大的问题就是它对于 空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行 数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显 提高磁盘的 I/O 次数。

相对来快速排序来 说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更 高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。


## Java 排序实现

Java Arrays.sort() 中的排序算法主要分为两种：基础数据类型排序、对象排序

### 基础数据类型排序

基础类型排序采用 **双轴快排**。基本思想是将待排序区域分为三个部分：less、mid、more

### 对象排序

对象排序需要保持 **稳定性**。
JDK1.7 之前采用 MergeSort，即 JDK1.8 中的 LegacyMergeSort。具体为集合小于 7 时，使用插入排序；大于 7 时，先递归分解为若干等于 7 的子集合，再采用插入排序进行子集合的排序，最后合并。

这是因为插入排序在小集合排序上最坏实际复杂度和 MergeSort 运算量差不多，但最好情况优于 MergeSort。

JDK1.8 后采用 TimSort(Tim Peters 发明)，是一个稳定的具有自适应性的 MergeSort 算法。

## 总结

* 本文共介绍了 10 种常用算法
* 注意每个算法的 
  * 时间（最好、最坏、平均）复杂度
  * 空间复杂度
  * 稳定性
  * 适用场景、缺点、优点
  * 优化算法
* 快速排序常用的原因：时间、空间、局部性原理
* Java 中 sort 的基本原理

*参考*：

[算法知识总结](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.md#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)

[男科一梦（再续一集）-TimSort的实现](https://mp.weixin.qq.com/s?__biz=MzI2MTY0OTg2Nw==&mid=2247483816&idx=1&sn=079af3d70efcb68efa7400f09decb59c&chksm=ea56650cdd21ec1ace7c8fd168d62feb636e4b32f9a4d90329fe479489d8e7a70e612df8920b&token=2074049324&lang=zh_CN#rd)

[基数排序](https://www.bilibili.com/video/BV184411L79P)