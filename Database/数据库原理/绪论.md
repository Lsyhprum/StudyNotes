# 数据库、数据库系统、数据库管理系统

## 数据库 (DB)

长期储存在计算机内的、有组织的、可共享的 **数据集合**

## 数据库系统

在计算机系统中引入数据库后的系统构成。一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员构成。

## 数据库管理系统 (DBMS)

位于用户和操作系统间的 **数据库管理软件**

# 文件系统与数据库系统

## 区别

* 文件系统共享性差、冗余度大、数据独立性差、记录内有结构、整体无结构，由应用程序自己控制
* 数据库系统共享度高、冗余度小、整体结构化，由数据库管理系统提供数据完整性、安全性、并发控制和恢复能力
* 文件系统是操作系统的重要组成部分，而DBMS是独立于操作系统的软件

## 联系

* DBMS是在操作系统的基础上实现的，数据库中的数据的组织和存储是通过操作系统中的文件系统来实现的

# 事务

## 概念

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚

## ACID

* 原子性 (Atomicity): 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚

* 一致性 (Consistency): 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的

* 隔离性 (Isolation): 一个事务所做的修改在最终提交以前，对其它事务是不可见的

* 持久性 (Durability): 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失

## ACID 联系

* 只有满足一致性，事务执行结果才是正确的

* 无并发情况下，满足原子性，就能满足一致性

* 并发情况下，多个事务并行执行，事务不仅需要满足原子性，还要满足隔离性，才能满足一致性

* 持久化是为了面对系统崩溃情况

## AUTOCOMMIT

MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。

# 并发一致性问题

## 丢失修改

A 改 B改 同时修改

考虑飞机订票系统中的一个活动序列: 

甲售票点（甲事务）读出某航班的机票余额A,设A=16. 
乙售票点（乙事务）读出同一航班的机票余额A,也为16. 
甲售票点卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库. 
乙售票点也卖出一张机票,修改余额A←A-1.所以A为15,把A写回数据库. 

结果明明卖出两张机票，数据库中机票余额只减少1。 

## 读脏数据

A 改 B 读 A Rollback B错

读"脏"数据是指事务T1修改某一数据，并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤消，这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，则T2读到的数据就为"脏"数据，即不正确的数据

## 不可重复读

A读 B 改 A 读，重复读取结果不一样 

可重复读包括三种情况： 

事务T1读取某一数据后，事务T2对其做了修改，当事务1再次读该数据时，得到与前一次不同的值。例如，T1读取B=100进行运算，T2读取同一数据B，对其进行修改后将B=200写回数据库。T1为了对读取值校对重读B，B已为200，与第一次读取值不一致。 
事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神密地消失了。 
事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。（这也叫做幻影读 ） 

### 幻影读

读时插入

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

# 封锁类型

一个事物对数据加锁可以保证事物的四个特性，加锁后其他事物不能更新此数据对象，不会产生数据不一致性。

## 读写锁

* 互斥锁，X 锁，写锁

* 共享锁，S 锁，读锁


## 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

* 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；

* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

# 封锁协议

## 一级封锁协议

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

## 二级封锁协议

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

## 三级封锁协议

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

# 关系数据库设计理论

## 范式

范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。

* 第一范式：

符合1NF的关系中的每个属性都不可再分

会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于表3中的设计

* 数据冗余过大 —— 多个属性重复

* 插入异常 ——  新建院系，无法单独插入

* 删除异常 —— 删除系中学生信息，讲系和系主任删除也删除

* 修改异常 —— 学生转系到法律系，需要修改3 条信息

* 第二范式：

2NF在1NF的基础之上，消除了非主属性对于码的传递函数依赖

函数依赖 x确定 -> y 确定

* 完全函数依赖 学号 -> 姓名

* 部分函数依赖 （学号，课名） - > 姓名

* 传递函数依赖 

* 码/候选码 -> x 确定，其他属性也确定（可能多个码，选择一个主码）

* 主属性：任意一个码中属性称为主属性

* 非主属性


可以通过分解来满足。

* 第三范式：

2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖

* BCNF

何非主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）


## 索引

* B+Tree 索引

因为 B+ Tree 的 有序性，因此可用于 部分查找、范围查找、排序 和 分组。

* Hash 索引

Hash 索引能以 O(1) 时间进行查找，但是失去了有序性。因此无法用于排序与分组，无法用于部分查找和范围查找，只支持 精确查找

## 优点

大大减少了服务器需要扫描的数据行数。

## 缺点

索引并不是越多越好，索引固然可以提高相应的 SELECT 的效率，但同时也降低了 INSERT 及 UPDATE 的效率，因为 INSERT 或 UPDATE 时有可能会 重建索引。


### 场景

对于 非常小的表：大部分情况下简单的 全表扫描 比建立索引更高效；
对于 中大型的表：建立索引 非常有效；
对于 特大型的表：建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配。例如可以使用 分区技术。

## 什么是视图，有什么作用？在数据库哪层？ 
视图：是从一个或几个基本表导出的表，是一个虚表，数据库只存放视图的定义，不存放视图对应的数据，数据仍放在原来的基本表，基本表数据改变，通过视图查询也改变了，

作用：1、能够简化用户操作，使数据库看起来更简单，清晰，简化查询操作。2、更安全，机密数据不出现在不应该看到这些数据的用户视图上。3、重构数据库时候，改变视图不用修改程序，使数据具有逻辑独立性。



        抽象         设计
现实世界 ----> E-R 图 ----> 计算机世界
     数据建模       数据库设计


关系数据库、面向对象数据库、xml、NoSQL、其他



哈工大

* 基本知识与关系模型
* 数据库语言 SQL
* 数据建模与数据库设计
* 数据库管理系统（数据库存取与控制）

逻辑-> 离散数学

数据结构-> 外存内存结合的数据结构（数据库系统）

编译原理-> 操作的执行

操作系统 -> 文件管理/内存管理

软件工程 -> 数据库的设计与实现