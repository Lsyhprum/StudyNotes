# 图的存储

## 邻接矩阵

使用二维数组 G[N][N] 的两维表示图的顶点标号

## 邻接表

### 链表

### vector

```cpp
struct Node{
    int v;
    int w;
};

vector<Node> Adj[N];
```

# 图的遍历

## DFS

[A1034]()

## BFS

[A1076]()

# 最短路径

给定图 G(V,E)，求一条从起点到终点的路径，使得这条路径上经过的所有边的边权之和最小。

# 最小生成树 (MST)

在给定 **无向图** 中求一棵树 T，其拥有图中所有顶点且边来自于图，整棵树的边权之和最小。求解最小生成树一般有两种方法，Prim 算法和 Kruskal 算法。这两个算法都采用了贪心法的思想。

## Prim 算法

Prim 算法与最短路径中 Dijkstra 算法思想完全相同。

寻找权重最小且不产生闭环的 N-1 条边。

```cpp
const int MAXV = 1000;
const int INF = 1000000000;

int n, G[MAXV][MAXV];
int d[MAXV];
bool visit[MAXV] = {false};

int prim(){
    fill(d, d + MAXV, INF);
    d[0] = 0;

    int ans = 0;
    for(int i = 0; i < n; i ++){
        int u = -1, MIN = INF;
        for(int j = 0; j < n; j ++){
            if(!visit[j] && d[j] < MIN){
                u = j;
                MIN = d[j];
            }
        }

        if(u == -1) return -1;
        visit[u] = true;
        ans += d[u];

        for(int k = 0; k < n; k ++){
            if(!visit[k] && G[k][u] != INF && G[k][u] < d[k]){
                d[k] = G[k][u];
            }
        }
    }

    return ans;
}
```

## Kruskal 算法

Kruskal 简单粗暴，但需要借助并查集。

在初始状态是隐去图中所有边，这样图中每个顶点都自成一个连通块。接着执行下面的步骤：

* 对所有边按边权从小到大排序

* 从小到大测试所有边，若当前测试边两个顶点都不在一个连通块，则加入到当前最小生成树，否则舍弃

* 执行步骤 2，直到最小生成树边数等于总顶点数减一，或测试完所有边时结束，若生成树边数小于总顶点数减一，说明图不连通

```cpp
int father[N];
int findFather(int x){}

int kruskal(int n, int m){
    int ans = 0, Num_Edge = 0;
    for(int i = 1; i <= n; i ++){
        father[i] = i;
    }

    sort(E, E+m, cmp);

    for(int i = 0; i < m; i ++){
        int faU = findFather(E[i].u);
        int faV = findFather(E[i].v);

        if(faU != faV){
            father[faU] = faV;
            ans += E[i].cost;
            Num_Edge ++;
            if(Num_Edge == n-1) break;
        }    
    }

    if(Num_Edge != n-1) return -1;
    else return ans;
}
```



## Prim 和 Kruskal

* Prim 适合稠密图，Kruskal 适合稀疏图（大部分情况 Kruskal 更好）


# 拓扑排序

# 关键路径