# 简单数学

[PAT B1019/A1069](https://github.com/Lsyhprum/PAT/tree/master/B1019)

# 最大公约数与最小公倍数


1. 递归的两个关键：**递归式**、**递归边界**

2. gcd（Greatest Common Divisor） : 欧几里得算法（辗转相除法）
    1. 递归式：gcd(a, b) == gcd(b, a % b)
    2. 边界条件：gcd(a, 0) = a

3. lcm (Least Common Multiple) : a / db（ab 可能溢出）

# 分数的四则运算

# 素数

素数又称质数，是指除了 1 和本身外，不能被其他树整除的一类数。

**易错：1 既不是素数，也不是合数**

## 素数的判断

若 2 ~ n-1 内存在 n 的约数 k, 则 n/k 也是 n 的一个约数，则 k 与 n/k 必满足一个小于等于 sqrt(n), 一个大于等于 sqrt(n)。

因此，判定 n 能否被 2，3，..., (int)sqrt(n) 整除即可(**易错：包含(int)sqrt(n)**)。

```cpp
for(int i = 2; i*i <=n; i ++){}
```

这种写法 i * i 易导致范围上界溢出，因此建议开根号的写法。

## 素数表

### 暴力法

O(n*sqrt(n)), n 范围小于 10^5

```cpp
bool is_prime(int n){
    for(int i = 2; i <= (int)sqrt(n); i ++){  //（int)sqrt() 边界易错
        if(n % i == 0)
            return false;
    }
    return true;
}

void find_prime(){
    for(int i = 2; i < maxn; i ++){
        if(is_prime(i))
            prime[++ pNum] = i;
    }
}
```

### 筛法

算法从小到大枚举所有数，对每一个素数，筛去它所有倍数，剩下的就是素数。

O(nloglogn), 范围更大，但需要确定大致范围（机试可先测试一遍）

```cpp
void find_prime(){
    for(int i = 2; i < maxn; i ++){
        if(!p[i]){                              // p[i] false 则 i 为素数
            prime[++ pNum] = i;
        }
        for(int j = i + i; j < maxn; j += i){   // j+=i 易错
            p[j] = true;
        }
    }
}
```

[PAT B1013](https://github.com/Lsyhprum/PAT/tree/master/B1013)

# 质因子分解

1. 需要使用素数表，则先估算大致范围并求出素数表, **int 类型质因数分解范围 大致为 10^5**

2. long int = int

3. 质因子分解常用结构体

```cpp
struct factor{
   int x, cnt;    
}fac[10]; //int 类型 fac 数组开到 10
```

[PAT A1059](https://github.com/Lsyhprum/PAT/tree/master/A1059)

# 大整数运算

# 扩展欧几里得算法

# 组合数